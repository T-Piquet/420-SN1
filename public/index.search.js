var relearn_search_index = [
  {
    "content": "Ici se trouve quelques informations pouvant vous être utile pour votre session.\n",
    "description": "",
    "tags": null,
    "title": "Base De Connaissances",
    "uri": "/base-de-connaissances/index.html"
  },
  {
    "content": "\rAtelier Atelier sur les bases de python\nExemples Exemples en .ipynb\n",
    "description": "",
    "tags": null,
    "title": "Bases de Python",
    "uri": "/cours/bases-de-python/index.html"
  },
  {
    "content": "\rCycle de développement logiciel Le cycle de développement d’un logiciel se décompose en plusieurs étapes que nous pouvons retrouver à travers ce schéma :\nGoffinet, F. (2021, 11 novembre). Concepts de développement logiciel.\nLe schéma représente un cercle fermé car un logiciel ne “meurt” jamais. Il est en constante évolution dû à des besoins utilisateurs grandissants.\nAlgorithme Qu’est-ce qu’un algorithme ?\nUn algorithme est une suite d’actions qui suivent un ordre précis. Cette suite d’actions est représente les traitements sur les données. Un algorithme ne s’exécute pas, il représente les étapes que le programme devra faire. Un algorithme doit être clair et précis. Avant de coder la solution, un algorithme doit être traduit en ordinogramme. Exemples d’algorithmes que vous connaissez déjà :\nUne recette de cuisine. Les instructions pour assembler un meuble. Les instructions pour préparer un café chaud avec du lait. La méthode pour calculer la somme des nombres de 1 à 100. Etc. Ordinogramme Un ordinogramme, aussi appelé organigramme de programmation est une représentation graphique de l’enchaînement des opérations, des décisions ou des fonctions à réaliser par un programme. Le programmeur devra traduire l’ordinogramme à l’aide d’un langage de programmation. L’organigramme de programmation utilise des symboles normalisés représentés ci- dessous : Qu’est-ce qu’un programme ? Un programme est une suite d’instructions écrites dans un langage de programmation qu’un système informatique comprend et exécute. Un programme résulte des instructions (étapes) définies dans l’ordinogramme. Qu’est-ce qu’un langage de programmation ? Un langage de programmation est un ensemble de mots clés et des règles de syntaxe qui permettent d’écrire un programme exécutable par un système informatique. Ex: Python, Java, C#, Matlab, …. Langages de programmation les plus populaires : TIOBE Index - TIOBE Et le gagnant est….\nPourquoi le python ? Python est un langage interprété orienté objet. C’est un langage très facile à prendre en main. Sa syntaxe simple offre une multitude de possibilité de développement. Il est possible de créer ses propres modules qui seront ensuite partagées à la communauté. Exemple : pipy.\nC’est un “vrai” langage :\ntypes de données, branchements conditionnels, boucles, procédures et fonctions, objets et classes, découpages en modules. Python propose les outils standards suivants :\nDonnées typées : entiers, réels, booléens, chaîne de caractères. Structures avancées de données : listes, dictionnaires, classes. Séquences d’instructions : écrire et exécuter une série de commandes sans avoir à intervenir entre les instructions. Structures algorithmiques : branchements conditionnels et boucles. Programmation structurée : utiliser les procédures et fonctions pour mieux organiser son code. Appeler plusieurs fichiers d’extension “.py” dans d’autres programmes à l’aide de la commande “import”. Exemple de programme simple dans python :\n# Exemple d'un programme simple qui effectue la somme de 2 nombres # Données en entrée x = 5 y = 7 # Traitement somme = x + y # Affichage print(f'La somme {x} + {y} est égale à {somme}') Exemple à télécharger\nVoyons ensemble comment exécuter ce programme.\nQu’est-ce que l’analyse du problème ? L’analyse du problème\nL’analyse du problème est une étape cruciale dans le processus de résolution de problèmes en informatique. Elle implique la détermination des données d’entrée, des données de sortie et de la nature des traitements. Les données d’entrée\nLes données d’entrée sont les informations dont nous disposons au début. En bref, la question qui se pose est de quoi avons nous besoin pour obtenir le résultat recherché? Les données en entrée peuvent provenir de diverses sources, comme des observations, des mesures, des expériences ou même des hypothèses. Par exemple, si nous étudions la croissance des plantes, les données d’entrée pourraient être la quantité de lumière, la température, le type de sol, etc. Les données de sortie\nLes données de sortie sont les résultats que nous souhaitons obtenir à partir des données d’entrée. Dans l’exemple de croissance des plantes, les données de sortie pourraient être la hauteur de la plante, le nombre de feuilles, la couleur des fleurs, etc. Les traitements\nLes traitements sont les modifications, manipulations faites sur les données d’entrée pour obtenir les données de sortie. Cela peut impliquer des calculs mathématiques, des expériences en laboratoire, des simulations informatiques, etc. Dans l’exemple de la croissance des plantes, le traitement pourrait consister à planter des graines dans différents types de sol et à mesurer leur croissance au fil du temps. En résumé, l’analyse du problème est une étape essentielle qui nous permet de comprendre clairement ce que nous savons, ce que nous voulons savoir et comment nous allons utiliser les informations disponibles pour obtenir les résultats souhaités. C’est une compétence précieuse pour tout scientifique en herbe.\nAtelier Télécharger le fichier ci-dessous et compléter les exercices : Analyse du problème\nRAPPEL : Vous devez terminer ces 5 exercices avant la fin de la séance.\n",
    "description": "",
    "tags": null,
    "title": "Introduction à la programmation",
    "uri": "/cours/introduction-%C3%A0-la-programmation/index.html"
  },
  {
    "content": "\rQu’est-ce qu’une chaine de caractères ? Une chaine de caractères est simplement plusieurs caractères regroupés ensemble. Les caractères peuvent être des lettres, chiffres, symboles ou espaces. Les chaines de caractères sont des objets que nous pouvons manipuler. Nous pouvons concaténer des chaines, extraire ou chercher des sous-chaines, les modifier, etc…\nEn python, les chaines de caractères sont entourées de guillemets simples (') ou doubles (\"):\nuneChaine = 'Bonjour' uneAutre = \"Allo\" Les chaînes en Python sont immuables, ce qui signifie qu’une fois créées, elles ne peuvent pas être modifiées. Toute opération qui semble modifier une chaîne crée en réalité une nouvelle chaîne. Pour l’utilisateur (programmeur), l’immutabilité est transparente dans la plupart des cas.\nComment utiliser une chaine de caractères ? Fonctions, Opérations et Méthodes Fonctions len() Retourne la longueur de la chaine str() Convertit en chaine de caractères Opérations * Multiplie une chaine + Concatène des chaines Méthodes [] Accède à un caractère selon sa position lower() Convertit tous les caractères de la chaîne en minuscules upper() Convertit tous les caractères de la chaîne en majuscules. strip() Supprime les espaces (ou autres caractères spécifiés) au début et à la fin de la chaîne replace() Remplace toutes les occurrences de la sous-chaîne split() Divise la chaîne en une liste de sous-chaînes join() Concatène une séquence d’éléments (comme une liste) en une seule chaîne find() Renvoie l’indice de la première occurrence de la sous-chaine Les indices Exemples Exemples sur les chaines de caractères\nCharactères “spéciaux” Caractère \\t Tabulation \\n Retour de ligne \\\\ Barre oblique inversée (Backslash) Le \\ permet d’échapper le caractère suivant.\nInsertion de variables Il est possible d’insérer facilement des variables dans des chaines de caractères. Une première solution est d’utiliser la concaténation:\nvar1 = 23 var2 = 35 laChaine = \"Le nombre \" + str(var1) + \" est plus petit que \" + str(var2) print(laChaine) # Affiche: Le nombre 23 est plus petit que 35 Mais il est préférable d’utiliser le f-strings :\nvar1 = 23 var2 = 35 laChaine = f'Le nombre {var1} est plus petit que {var2}' print(laChaine) # Affiche: Le nombre 23 est plus petit que 35 Dans une boucle Il est possible d’itérer sur chaque lettre de la chaine:\nfor lettre in \"Bonjour\": print(lettre) Ateliers Atelier sur les chaines de caractères\n",
    "description": "",
    "tags": null,
    "title": "Les Chaines de caractères",
    "uri": "/cours/les-chaines-de-caract%C3%A8res/index.html"
  },
  {
    "content": "\rQu’est-ce qu’une Librairie système ? En Python, les librairies système fournissent des interfaces pour interagir avec le système d’exploitation et les ressources matérielles sous-jacentes.\nUne librairie système est un ensemble de modules et de fonctions fournies par le système d’exploitation ou par des bibliothèques externes qui permettent aux programmes :\nDe communiquer avec le système d’exploitation D’accéder aux ressources matérielles De gérer des processus De manipuler des fichiers D’effectuer d’autres opérations système de bas niveau. Exemple import os # importation de la librairie os print(os.listdir('.')) # Liste les fichiers dans le répertoire courant os.mkdir(\"foo\") # Crée le répertoire foo Librairie os Ce module permet d’utiliser les fonctionnalités dépendantes du système d’exploitation telles que :\nLa gestion des fichiers et des répertoires L’exécution de commandes système Il faut d’abord importer la librairie :\nimport os Fichiers et Répertoires Qu’est-ce qu’un fichier ? Un fichier est une unité de stockage sur un ordinateur. Pensez à un fichier comme à une feuille de papier où vous pouvez écrire des informations. Les fichiers peuvent contenir différents types de données, comme du texte, des images, de la musique, des vidéos, ou des programmes.\nQu’est-ce qu’un répertoire ? Un répertoire, aussi appelé dossier, est un conteneur qui peut contenir des fichiers et d’autres répertoires. Imaginez un répertoire comme un classeur où vous pouvez organiser vos feuilles de papier (fichiers) en différentes sections (sous-dossiers).\nOrganisation des fichiers et des répertoires Les fichiers et les répertoires sont organisés dans une structure hiérarchique, souvent comparée à un arbre :\nRépertoire racine : Le répertoire principal qui contient tous les autres fichiers et répertoires. Sur Windows, il est souvent appelé C:\\. Sur macOS et Linux, il est appelé /. Sous-répertoires : Répertoires à l’intérieur d’autres répertoires. Ils permettent d’organiser les fichiers de manière logique. Par exemple, un répertoire Documents peut contenir des sous-répertoires pour des projets, des factures, etc. Chemin d’accès : La manière dont on désigne l’emplacement d’un fichier ou d’un répertoire. Par exemple, le chemin d’accès à une vidéo peut être C:\\Vidéo\\Archives\\video_01.mkv sur Windows. Dans cet exemple, Image, Musique et Vidéo sont es sous-répertoire de Racine.\nLe répertoire Vidéo contient un sous-répertoire Archives et un fichier video_03.mkv.\nLe répertoire Musique est vide.\nChemins relatif vs absolu Un chemin absolu part toujours de la racine.\nExemple:\nC:\\Vidéo\\Archives\\video_01.mkv Un chemin relatif part d’où nous sommes. Par exemple, si un programme est exécuté dans le répertoire Vidéo, son point de départ sera Vidéo. Les .. permettront de remonter au répertoire parent.\nExemples (à partir de Vidéo):\nPour accéder à video_01.mkv: .\\Archives\\video_01.mkv Pour accéder à image_01.png: ..\\Image\\image_01.png Gestion de fichiers et répertoires Lister les fichiers et les répertoires liste = os.listdir() # liste des fichiers/répertoires du répertoire courant liste = os.listdir('foo') # liste des fichiers/répertoires du sous-répertoire \"foo\" liste = os.listdir('..') # liste des fichiers/répertoires du répertoire parent liste = os.listdir('C:\\Vidéo\\Archives') # liste des fichiers/répertoires du répertoire \"Archives\" Créer un répertoire os.mkdir('nouveau_repertoire') # Crée le répertoire \"nouveau_repertoire\" dans le répertoire courant Combiner des composants de chemin chemin = os.path.join('repertoire', 'fichier.txt') # Crée le chemin à partir des chaines \"repertoire\" et \"fichier.txt\" os.path.join prend en compte le système d’exploitation pour combiner les composantes du chemin.\nSous Windows, chemin sera repertoire\\fichier.txt, tandis que sous Linux, il sera repertoire/fichier.txt.\nCe qui permettra à ce programme s’exécuter peu importe le système d’exploitation.\nVérifier si un chemin est un fichier/répertoire estFichier = os.path.isfile('repertoire/fichier.txt') # Retourne Vrai si le fichier existe, sinon Faux estRepertoire = os.path.isdir('repertoire') # Retourne Vrai si le répertoire existe, sinon Faux La fonction os.path.exists() est plus générale et indique si le chemin existe. Cette fonction est très utilise pour éviter les erreurs:\nif os.path.exists('repertoire/fichier.txt'): # Si le fichier n'existe pas, la lecture n'aura pas lieu with open('repertoire/fichier.txt', 'r') as fichier: contenu = fichier.read() print(contenu) Supprimer un fichier/répertoire os.remove('fichier.txt') # Supprime le fichier \"fichier.txt\" os.rmdir('repertoire') # Supprime le répertoire \"repertoire\" et tout ce qui se trouve à l'intérieur Gestion de processus Exécuter une commande système La fonction os.system() permet d’exécuter des commandes système. Les commandes système sont dépendantes de votre système d’exploitation (ex: Windows vs Linux). Donc, les commandes devront être ajustées en conséquence.\nPar exemple, sous Windows, la commande dir permet d’obtenir la liste des fichiers et répertoires. Tandis que sous Linux, la commande est ls.\nos.system('ls') # Liste des fichiers et répertoire sous Linux os.system('dir') # Liste des fichiers et répertoire sous Windows Cet exemple est seulement pour illustrer la différence entre les systèmes d’exploitation. Il aurait été préférable d’utiliser la commande os.listdir() qui a la même fonctionnalité que ls ou dir, mais fonctionne sur toutes les plateformes.\nIl est possible d’exécuter d’autres programmes à l’aide la de commande os.system(). Par exemple, il est possible d’exécuter une autre script Python:\n# premierProgramme.py print('Bonjour') # deuxiemeProgramme.py os.system('python premierProgramme.py') Si on exécute deuxiemeProgramme.py, celui-ci appellera à son tour le programme premierProgramme.py qui lui affichera Bonjour.\nLibrairie sys Ce module fournit des fonctions et des variables utilisées pour manipuler différentes parties de l’environnement d’exécution Python, telles que les arguments de la ligne de commande, les variables d’environnement, le chemin de recherche de modules, etc.\nLes arguments Il est possible de lancer un programme python avec des arguments. On utilise sys.argv pour accéder à ceux-ci. sys.argv est une liste contenant les arguments sous forme de chaine de caractères (string). La première valeur est le nom du programme.\nExemple:\n# addition.py # Programme utilisant des arguments import sys print(\"Programme:\", sys.argv[0]) # Affichera le nom du programme, soit \"addition.py\" nombre_1 = int(sys.argv[1]) # \"nombre_1\" devient la valeur numérique du 1er argument nombre_2 = int(sys.argv[2]) # \"nombre_2\" devient la valeur numérique du 2e argument reponse = nombre_1 + nombre_2 print(\"Réponse:\", reponse) addition.py\nPour lancer le programme à la ligne de commande:\n# Windows\rpython addition.py 2 3 # Devrait donner la réponse 5\r# Linux\rpython3 addition.py 2 3 Essayez de lancer le programme sans argument.\nModifiez le programme pour éviter cette erreur.\nSortir du programme Si tout ce passe bien, les programmes terminent normalement lorsqu’il n’y a plus de code à exécuter.\nDans ce cas, le programme retournera la valeur 0.\nSi une erreur se produit en cours d’exécution et que le programme s’arrête anormalement, une valeur différente de 0 sera retournée.\nL’utilisateur du programme pourra utiliser la documentation pour connaître la signification de ce code d’erreur.\nLa fonction sys.exit() permet de sortir du programme immédiatement en retournant un code.\n# addition_2.py # Programme utilisant des arguments import sys print(\"Programme:\", sys.argv[0]) # Affichera le nom du programme, soit \"addition.py\" if len(sys.argv) != 3: print(\"Vous devez fournir 2 arguments pour l'addition\") sys.exit(1) if not sys.argv[1].isdigit() or not sys.argv[2].isdigit(): print(\"Vous devez fournir des arguments numériques pour l'addition\") sys.exit(2) nombre_1 = int(sys.argv[1]) # \"nombre_1\" devient la valeur numérique du 1er argument nombre_2 = int(sys.argv[2]) # \"nombre_2\" devient la valeur numérique du 2e argument reponse = nombre_1 + nombre_2 print(\"Réponse:\", reponse) addition_2.py\nExemple :\n# Windows\rpython addition_2.py 2 3 # Devrait donner la réponse 5\recho %ERRORLEVEL% # Devrait donner 0\rpython addition_2.py 2 # Erreur\recho %ERRORLEVEL% # Devrait donner 1\rpython addition_2.py 2 a # Erreur\recho %ERRORLEVEL% # Devrait donner 2\r# Linux\rpython3 addition_2.py 2 # Erreur\recho $? # Devrait donner 1 Valeur Maximale En python, la valeur maximale d’un int est de 9223372036854775807. Il est possible d’utiliser cette valeur à l’aide de sys.maxsize.\nimport sys print('Maximum :', sys.maxsize) # Affiche 9223372036854775807 Exemple d’utilisation pour trouver la valeur minimale dans une liste:\nimport sys maListe = [7,5,3,4,5,7,6,1,2,6] minimumTrouve = sys.maxsize # On initialise minimumTrouve avec une très grande valeur for val in maListe: if val \u003c minimumTrouve: minimumTrouve = val print(\"La valeur minimale est :\", minimumTrouve) Ateliers Atelier sur les librairies\nExemples Exemples en .ipynb\n",
    "description": "",
    "tags": null,
    "title": "Les Librairies systèmes",
    "uri": "/cours/les-librairies-syst%C3%A8mes/index.html"
  },
  {
    "content": "\rPourquoi utiliser des listes ? Mise en situation Vous devez gérer les données des étudiants du cours. Chaque étudiant a un nom et un âge. Vous ne savez pas combien d’étudiants seront inscrits dans le cours. Vous devez afficher le nom de tous les étudiants et leur âge.\nSolution sans liste # On saisit chaque variable etudiant_01_nom = \"Emma\" etudiant_01_age = 18 etudiant_02_nom = \"Julien\" # .... etudiant_37_age = \"20\" # On affiche les noms et âge un par un print(etudiant_01_nom, etudiant_01_age) # .... print(etudiant_37_nom, etudiant_37_age) Solution avec une liste L’utilisation des listes permettra d’exécuter cette tâche beaucoup plus facilement. Vous pourrez ajouter/modifier/enlever des étudiants. Et vous pourrez ajouter plusieurs informations pour chaque étudiant.\n# On remplit la liste etudiants = [] etudiants.append([\"Emma\", 18]) etudiants.append([\"Julien\", 17]) .... etudiants.append([\"Sophie\", 20]) # On affiche les noms et âge dans une boucle for e in etudiants: print(e[0], e[1]) Qu’est-ce qu’une liste ? En Python, une liste est une collection ordonnée et modifiable d’éléments. Les listes sont utilisées pour stocker plusieurs éléments dans une seule variable et peuvent contenir des éléments de différents types, y compris des nombres, des chaînes de caractères, d’autres listes, etc. Les listes en Python sont définies en utilisant des crochets [].\nCaractéristiques d’une liste Ordonnée : Les éléments de la liste conservent un ordre défini, ce qui signifie que l’ordre dans lequel vous ajoutez les éléments est préservé. Modifiable : Une liste peut être modifiée après sa création, ce qui signifie que vous pouvez ajouter, supprimer ou changer des éléments. Taille Dynamique : Une liste en Python peut changer de taille dynamiquement. Vous pouvez ajouter ou supprimer des éléments sans avoir à spécifier la taille initiale de la liste. Hétérogène : En Python, une liste peut contenir des éléments de différents types (entiers, chaînes de caractères, listes, etc.). Bien qu’il est possible de le faire, il faut rester prudent lorsqu’on utilise des listes hétérogènes. Elles pourraient entraîner des erreurs, notamment dans les boucles. Comment utiliser une liste ? Fonctions et méthodes Fonctions len() Retourne la longueur de la liste max() Retourne la valeur maximum de la liste min() Retourne la valeur minimum de la liste Méthodes append() Ajoute un élément à la fin de la liste insert() Ajoute un élément à un endroit spécifique dans la liste remove() Supprime un élément de la valeur spécifiée pop() Supprime un élément selon sa position et retourne la valeur del() Supprime un élément selon sa position [] Permet d’accéder à un élément de la liste selon sa position extend() Ajoute tous les éléments d’une liste dans une autre liste clear() Efface tous les éléments d’une liste index() Retourne l’indice du premier élément dont la valeur est égale à celle spécifiée sort() Trie les éléments de la liste reverse() Inverse l’ordre des éléments de la liste copy() Retourne une copie superficielle de la liste Opérations simples Création d’une liste # Création d'une liste vide maListe = [] # ou maListe = list() # Liste avec des éléments maListe = [6, 3, 8, 9, 7, 3, 1, 2] Accès aux Éléments d’une Liste Les crochets [] sont utilisés pour accéder directement à l’élément correspondant.\n# Accès au premier élément print(maListe[0]) # Affiche 6 # Accès au dernier élément print(maListe[-1]) # Affiche 2 # Opérations sur les éléments de la liste x = maListe[1] + maListe[3] # est l'équivalent de 3 + 9, soit les éléments qui se trouve aux indices 1 et 3 print(x) # Affiche 12 Notez que les indices commencent à zéro.\nAjout d’Éléments # Liste vide maListe = [] # Ajoute la valeur 6 à la fin de la liste maListe.append(6) # Ajoute la valeur 3 à la fin de la liste maListe.append(3) maListe.append(8) maListe.append(9) maListe.append(7) maListe.append(3) maListe.append(1) maListe.append(2) Modification des Éléments # La valeur de la case à l'indice 2 est maintenant 0 maListe[2] = 0 # La valeur de la case à l'indice 4 est maintenant la même que celle de la case à l'indice 7 maListe[4] = maListe[7] # isch... maListe[0] = maListe[maListe[7]] # Décomposition du problème indice = maListe[7] # indice vaut 2 nouvelleValeur = maListe[indice] # nouvelleValeur vaut maListe[2], soit 0 maListe[0] = nouvelleValeur # La case à l'indice 0 vaut maintenant 0 # Même logique... maListe[4] = maListe[maListe[7] + maListe[6]] # Décomposition du problème indice = maListe[7] + maListe[6] # indice vaut 3 nouvelleValeur = maListe[indice] # nouvelleValeur vaut maListe[3], soit 9 maListe[4] = nouvelleValeur # La case à l'indice 4 vaut maintenant 9 Suppression d’Éléments # Supprime le dernier élément de la liste maListe.pop() # Supprime l'élément à l'indice 2 maListe.pop(2) # Supprime la première occurrence de la valeur 3 maListe.remove(3) Insertion # Insert la valeur 7 à la case 3 maListe.insert(3, 7) Triage # La liste est triée en ordre croissant maListe.sort() # La liste est triée en ordre décroissant maListe.sort(reverse=True) Dans une boucle Il est possible de parcourir chacun des éléments de la liste avec une boucle FOR:\n# Affichage de chacun des éléments de la liste for element in maListe: print(element) Il est aussi possible d’utiliser la fonction range() afin de parcourir la liste à l’aide des indices:\n# On additionne 1 à chaque élément de la liste for i in range(len(maListe)): maListe[i] = maListe[i] + 1 Il est aussi possible de parcourir une liste dans une boucle WHILE:\n# On affiche les premiers éléments de la liste. # On arrête dès que le total atteint au moins 10 maListe = [1, 2, 3, 4, 5, 6, 7] total = 0 i = 0 while total \u003c 10: print(maListe[i]) i += 1 Les listes dans les listes Il est possible de mettre n’importe quel type d’élément dans les listes. Il est donc possible de mettre des listes dans des listes. Nous parlons alors de listes (ou tableaux) en 2 dimensions.\n# Liste contenant 3 éléments # Chaque élément est une liste contenant 2 nombres matrice = [[1, 2], [3, 4], [5, 6]] Pour parcourir toutes les listes, il suffit de mettre une boucle dans une boucle :\n# On parcourt chaque éléments de la liste principale for sousliste in matrice: # et ensuite chaque élément de la \"sous-liste\" for e in sousListe: print(e) Les opérations vues sur les listes en 1 dimension fonctionnent aussi pour les listes en 2D:\nprint(matrice[0]) # affiche la première liste de la matrice print(matrice[0][1]) # affiche le 2e élément de la première liste de la matrice matrice.append([7, 8]) # ajoute une nouvelle liste à la matrice Il est aussi possible de parcourir les listes en utilisant les indices et la fonction range():\n# On ajoute 1 à chaque élément de la matrice for i in range(len(matrice)): for j in range(len(matrice[i])): matrice[i][j] += 1 Ateliers Atelier sur les listes\n",
    "description": "",
    "tags": null,
    "title": "Les Listes",
    "uri": "/cours/les-listes/index.html"
  },
  {
    "content": "\rQu’est-ce qu’un objet ? En programmation, un objet est une structure qui regroupe des données et des méthodes qui manipulent ces données. Les objets sont la pierre angulaire de la programmation orientée objet (POO), un paradigme qui organise le code en entités réutilisables et modulaires.\nConcept Définition Classe Une classe est un plan ou un modèle pour créer des objets. Objet Un objet est une instance d’une classe. Attributs Les attributs sont des variables qui appartiennent à une classe ou à un objet. Méthodes Les méthodes sont des fonctions définies à l’intérieur d’une classe. Exemple maListe = list() maListe.append(3) len(maListe) maListe est un objet créé à partir de la recette de la classe list. maListe contient plusieurs méthodes qui permettront de gérer/manipuler les données. Par exemple, append permet d’ajouter une donnée. len est une fonction externe à la classe qui permet d’obtenir le nombre de données que maListe contient.\nEncapsulation L’avantage des objets est que les méthodes et données sont encapsulés. L’utilisateur n’a pas besoin de comprendre en profondeur comment fonctionne l’objet. Il doit comprendre comment l’utiliser.\nDans l’exemple ci-haut, l’utilisateur doit comprendre que la méthode append ajoute une nouvelle valeur à la liste. Mais il n’a pas besoin de comprendre le code à l’intérieur de l’objet.\nMéthode vs Fonction Une fonction est un bloc de code qui effectue une tâche spécifique. Elle peut prendre des arguments comme entrée et peut retourner une valeur. Les fonctions sont définies indépendamment des objets et peuvent être appelées depuis n’importe où dans le code.\nUne méthode est similaire à une fonction, mais elle est associée à un objet. Les méthodes sont définies au sein d’une classe et sont appelées sur des instances de cette classe.\nL’une des différences les plus évidentes est dans la manière dont elles sont utilisées. Les méthodes sont appelées en ajoutant un point après la variable, suivi du nom de la méthode. Les fonctions, quant à elles, prennent la variable comme argument. Exemple:\nx = [1, 2, 3] x.append(4) # méthode permettant d'ajouter une valeur len(x) # fonction qui permet d'obtenir la longueur de la liste Ateliers Atelier sur les objets\n",
    "description": "",
    "tags": null,
    "title": "Les Objets",
    "uri": "/cours/les-objets/index.html"
  },
  {
    "content": "\rQu’est-ce qu’une Structure de Donnée en Python ? Une structure de donnée avancée en Python fait référence à des collections ou des types de données qui permettent de stocker, organiser et manipuler des données de manière efficace.\nNous avons déjà vu d’autres structures de données, soit les listes et les chaines de caractères.\nMaintenant, nous regarderons d’autres structures de données, soit les dictionnaires, les ensembles et les tuples:\nLes dictionnaires Les dictionnaires en Python sont des collections de paires clé-valeur. Chaque élément dans un dictionnaire a une clé unique et une valeur associée. Les dictionnaires sont très utiles pour stocker des données associées.\nPar exemple, un dictionnaire pourrait être utilisé pour maintenir un inventaire d’espèces d’arbres. Les espèces seront les clés et les quantités seront les valeurs:\nEspèces Quantité Chêne 30 Pin 15 Érable 25 Bouleau 42 Sapin 25 Donc, si vous avez besoin d’une quantité, vous utiliserez le tableau ci-dessus en cherchant l’espèce qui vous intéresse.\nLes dictionnaires fonctionnent très similairement:\n# On initialise le dictionnaire avec {} ou dict() monDictionnaire = {} # On ajoute des éléments monDictionnaire[\"Chêne\"] = 30 monDictionnaire[\"Pin\"] = 15 monDictionnaire[\"Érable\"] = 25 monDictionnaire[\"Bouleau\"] = 42 monDictionnaire[\"Sapin\"] = 25 # On accède à une valeur selon la clé x = monDictionnaire[\"Pin\"] # x vaut 15 # On modifie une valeur monDictionnaire[\"Érable\"] = 5 # La valeur de \"érable\" est remplacée par 5 # On supprime une paire monDictionnaire.pop(\"Sapin\") # La paire ayant la clé \"Sapin\" est effacée # On vérifie si une clé est présente uneEspece = \"Chêne\" if uneEspece in monDictionnaire: print(f'L\\'espèce {uneEspece} est présente.') else: print(f'L\\'espèce {uneEspece} n\\'est pas présente.') Notez\rLes clés doivent être de type immuable, c’est-à-dire qu’elle ne peuvent pas être modifiées. Dans la majorité de cas, les clés sont des chaines de caractères ou des nombres. Les clés doivent être unique. Il est aussi possible de parcourir les dictionnaires, c’est-à-dire d’itérer sur chacune des paires clé-valeur:\n# Initialisation avec les données monDictionnaire = {'Chêne': 30,'Pin': 15,'Érable': 25,'Bouleau': 42,'Sapin': 25} # Itération sur les clés for espece in monDictionnaire.keys(): print(espece) # Les clés seront affichées une après l'autre print(monDictionnaire[espece]) # La variable \"espece\" permet d'accéder à la quantité # Itération sur les valeurs for quantite in monDictionnaire.values(): print(quantite) # Les quantités seront affichées une après l'autre # Itération sur les paires clé-valeur for espece, valeur in monDictionnaire.items(): print(espece, valeur) # Les valeurs et quantités seront affichées une après l'autre Comme pour les listes, les valeurs d’un dictionnaire peuvent être complexes. Il est possible d’utiliser des dictionnaires ou des listes comme valeurs:\n# un inventaire vide inventaire = {} # Ajout d'une paire ayant comme clé : \"site_1\", et un dictionnaire comme valeur inventaire['site_1'] = {} # Ajout d'espèce et quantité dans le dictionnaire du site_1 inventaire['site_1']['Chêne'] = 30 inventaire['site_1']['Sapin'] = 15 inventaire['site_1']['Érable'] = 25 # Ajout d'un dictionnaire (avec information) à la clé \"site_2\" inventaire['site_2'] = {'Chêne': 7,'Érable': 25,'Bouleau': 42} # Il est possible d'ajouter d'autres dictionnaires à l'intérieur inventaire['site_1']['Pin'] = {} inventaire['site_1']['Pin']['Quantité'] = 125 inventaire['site_1']['Pin']['Rangée'] = \"A\" inventaire['site_1']['Pin']['Grandeur'] = [3, 8, 12] # Affichage à l'aide de pprint from pprint import pprint pprint(inventaire) Affiche:\n{'site_1': {'Chêne': 30, 'Sapin': 15, 'Érable': 25, 'Pin': { 'Grandeur': [3, 8, 12], 'Quantité': 125, 'Rangée': 'A' }, 'site_2': {'Bouleau': 42, 'Chêne': 7, 'Érable': 25 } } Notez\rLes dictionnaires ne sont pas ordonnés. Par exemple, l’affichage n’est pas dans le même ordre que l’ordre d’entrée. Les Ensembles (Set) Les ensembles (ou sets) en Python sont des collections non ordonnées d’éléments uniques. Ils sont utilisés pour stocker des éléments distincts et effectuer des opérations mathématiques comme l’union, l’intersection et la différence.\n# Initialisation d'un ensemble vide monEnsemble = set() # Ajout d'éléments monEnsemble.add(1) # contient 1 monEnsemble.add(2) # contient 1 et 2 monEnsemble.add(3) # contient 1, 2 et 3 monEnsemble.add(2) # contient 1, 2 et 3 # Initialisation d'un ensemble à partir d'une liste maListe = [1, 2, 3, 4, 3, 2, 1] # liste avec des doublons ensemble = set(maListe) # l'ensemble ne contient que [1, 2, 3, 4] # Suppresion d'une valeur ensemble.remove(1) # Supprime la valeur 1 # Vérifier si l'élément est présent if 2 in ensemble: print(f'Le chiffre 2 est dans l\\'ensemble') # Itération sur les valeurs for v in ensemble: print(v) # Affiche chaque valeur de l'ensemble Les ensembles supportent plusieurs opérations mathématiques :\nensemble1 = {1, 2, 3} ensemble2 = {3, 4, 5} # Union union = ensemble1 | ensemble2 print(union) # {1, 2, 3, 4, 5} # Intersection intersection = ensemble1 \u0026 ensemble2 print(intersection) # {3} # Différence difference = ensemble1 - ensemble2 print(difference) # {1, 2} # Différence symétrique difference_sym = ensemble1 ^ ensemble2 print(difference_sym) # {1, 2, 4, 5} Les Tuples Les tuples en Python sont des séquences ordonnées et immuables de valeurs. Contrairement aux listes, les tuples ne peuvent pas être modifiés après leur création.\nLes tuples\nPourquoi utiliser des tuples au-lieu des listes?\nContrairement aux listes, les tuples sont immuables. Dans biens des cas, cette immuabilité restreint leur utilisation et les listes sont préférées.\nPar contre, les tuples peuvent être utilisés comme clé dans les dictionnaires.\nExemple: Vous placez des objets sur un plan cartésien. Vous pourriez utiliser un tuple comme clé (x, y) et la description de l’objet comme valeur.\n# une carte vide carte = {} # ajout d'objets carte[(3, 5)] = \"Monstre\" # un Monstre à la position (3, 5) carte[(2, 8)] = \"Trésor\" # un Trésor à la position (2, 8) carte[(1, 3)] = \"Trou\" # un Trou à la position (1, 3) carte[(3, 4)] = \"Joueur\" # un Joueur à la position (3, 4) Ateliers Atelier sur les Structures de données\n",
    "description": "",
    "tags": null,
    "title": "Les Structures de Données",
    "uri": "/cours/les-structures-de-donn%C3%A9es/index.html"
  },
  {
    "content": "Qu’est-ce que le MarkDown Syntaxe ",
    "description": "",
    "tags": null,
    "title": "MarkDown",
    "uri": "/base-de-connaissances/markdown/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Ordinogramme",
    "uri": "/cours/ordinogramme/index.html"
  },
  {
    "content": "\rProjet - Fil rouge Le projet fil rouge est l’activité permettant d’évaluer l’atteinte de l’objectif intégrateur du cours. Il se déroulera sur les 5 dernières semaines de la session. Au cours des 4 premières semaines du projet, nous développerons un programme permettant d’explorer, analyser et visualiser des données scientifiques.\nLors de la 5e semaine du projet (dernier cours de la session), vous serez évalués. Votre programme devra être terminé et fonctionnel avant la dernière séance de cours. Votre programme devra être déposé sur Moodle avant la date limite (voir Moodle pour la date limite pour votre groupe).\nLors de l’évaluation, il vous sera demandé de modifier ou d’ajouter certaines fonctionnalités à votre programme. Le programme remis à la fin de cette évaluation sera évalué. Lors de l’évaluation, vous n’aurez pas accès à des ressources extérieures (Internet ou collègues). Le projet doit être fait individuellement (évaluation et préparation).\nLe projet comporte 4 parties :\nPartie 1 : Extraction des données Partie 2 : Nettoyage des données Partie 3 : Affichage des données Partie 4 : Analyse des données Mise en situation blabla….\nOn trouve un sujet (qui pourra être changé de session en session).\nFichiers Fichier Description projetFilRouge.ipynb Tout le projet devra être fait dans ce fichier. Les différentes parties sont bien identifiées. Ne sautez pas d’étapes. N’oubliez pas d’inscrire vos informations personnelles dans le haut du fichier. donnees.json Le fichier contenant les données pour le projet. ",
    "description": "",
    "tags": null,
    "title": "Projet - Fil Rouge",
    "uri": "/cours/projet-fil-rouge/index.html"
  },
  {
    "content": "\rObjectif Lorsque les données sont collectées, elles sont entreposées dans un certain format. Par la suite, ces données devront être analysées avec des outils qui ne sont pas nécessairement compatibles avec le format d’entreposage.\nIl est donc primordial d’être capable de passer d’un format à un autre.\nExtraction des données [ICI ON POURRAIT METTRE LA THÉORIE QU’ILS ONT BESOIN]\n[LES ÉTAPES À FAIRE DANS LE PROJET SERONT DANS LE .ipynb]\nEn science, l’extraction des données est la première étape … blabla\nFormat des données CSV [EXPLIQUER LE CSV]\nJSON [EXPLIQUER LE JSON]\nAUTRE FORMAT ???? [EXPLIQUER LE ????]\nExemple avec les APIs Les APIs sont une source très populaire pour fournir des données (ex: météo, jeux vidéo, etc). Les données fournies par les APIs sont plus souvent qu’autrement en format json.\nVoici des exemples d’utilisation:\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 1",
    "uri": "/cours/projet-fil-rouge/partie-1/index.html"
  },
  {
    "content": "\rObjectif ….\nNettoyage des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 2",
    "uri": "/cours/projet-fil-rouge/partie-2/index.html"
  },
  {
    "content": "\rObjectif …\nAffichage des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 3",
    "uri": "/cours/projet-fil-rouge/partie-3/index.html"
  },
  {
    "content": "\rObjectif …\nAnalyse des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 4",
    "uri": "/cours/projet-fil-rouge/partie-4/index.html"
  },
  {
    "content": "\rStructures conditionnelles - if Au cours de son déroulement, un programme a besoin de prendre des décisions en fonction des données qu’il rencontre.\nComment cela se traduit ?\nLa condition est très souvent une opération de comparaison. Attention au : qui est primordial. C’est l’indentation (le décalage par rapport à la marge gauche) qui délimite le bloc d’instructions. La partie else est facultative. Exemple simple # Nous demandons à l'utilisateur de saisir un âge age = int(input(\"Saisir votre âge :\")) # Nous testons l'âge à partir de la valeur saisie par l'utilisateur # Nous pouvons noter dans cet exemple la \"condition\" qui permet de définir, grâce à l'âge, si la personne est majeure ou mineure. if age \u003e= 18: print(\"Vous êtes majeur(e).\") else: print(\"Vous êtes mineur(e).\") L’ordinogramme suivant représente le code écrit ci-dessus :\nStructures conditionnelles - Succession de if avec elif Il est naturel de se retrouver à devoir prendre un décision en fonction de multiples choix. Comment cela fonctionne avec Python ?\n# Cet algorithme a pour but de permettre à un utilisateur de choisir sa position dans \"League of Legends\" print(\"1. Support\") print(\"2. Top\") print(\"3. Mid\") print(\"4. ADC\") print(\"5. Jungle\") # L'utilisateur saisir un code en fonction de sa position position = int(input(\"Choisissez votre position : \")) # Le code saisi dans la variable position est testé pour afficher la position du joueur if(position == 1): print(\"Vous êtes Support\") elif(position == 2): print(\"Vous êtes Top\") elif(position == 3): print(\"Vous êtes Mid\") elif(position == 4): print(\"Vous êtes ADC\") else: print(\"Vous êtes Jungle\") print(\"Bienvenue dans la faille de l'invocateur !\") print(\"Des sbires sont apparus.\") elif n’est déclenché que si la (les) condition(s) précédente(s) a (ont) échoué. elif est situé au même niveau que if et else. On peut en mettre autant que l’on veut. L’ordinogramme suivant représente le code écrit ci-dessus :\nAtelier Atelier sur les structures conditionnelles\nExemples Exemples en .ipynb\n",
    "description": "",
    "tags": null,
    "title": "Structures conditionnelles",
    "uri": "/cours/structures-conditionnelles/index.html"
  },
  {
    "content": "\rVScode \u0026 Jupyter Dans ce cours, nous allons utiliser deux outils pour analyser des données scientifiques avec Python. Il s’agit de Visual Studio Code et Jupyter Notebook.\nVisual Studio Code\nVisual Studio Code est comme un cahier de notes pour écrire du code.\nIl est gratuit et peut être utilisé avec beaucoup de langages de programmation, dont Python.\nIl a des fonctionnalités cool, comme :\naider à compléter le code. trouver des erreurs mettre en forme le code, etc. On peut aussi ajouter des extensions pour avoir plus de fonctionnalités, comme intégrer des bibliothèques scientifiques, des vérificateurs de code, des testeurs, etc.\nVisual Studio Code est donc un super outil pour écrire, exécuter et tester du code Python de manière efficace.\nL’interface de VS Code\nVisual Studio Code: Guide d’utilisation\nJupyter Notebook\nJupyter Notebook est comme un cahier de laboratoire interactif sur le web.\nOn peut y créer et partager des documents qui contiennent du code, des résultats, des explications, des graphiques, etc.\nC’est un outil très pratique pour :\nexplorer des données. faire des analyses. montrer des informations, etc. Il facilite la création de la documentation.\nJupyter Notebook peut être utilisé avec plusieurs langages de programmation, mais il est surtout utilisé avec Python.\nPour l’utiliser, il faut installer un environnement Python, qui fournit les bibliothèques nécessaires. Ces deux outils ont des avantages et des inconvénients, et ils sont complémentaires.\nSi vous souhaitez les installer, les configurer et les utiliser chez vous sur votre ordinateur personnel pour analyser des données scientifiques avec Python, ci-dessous vous trouverez des ressources utiles.\nInstallation des outils Pour ceux qui ont un système d’exploitation Windows, voici deux fichiers exécutables qui installeront automatiquement VS Code, Python et toutes les librairies nécessaires :\nPremière étape Deuxième étape Pour une installation manuelle : voici les liens utiles pour installer les outils de développement (sur votre ordinateur personnel):\nTélécharger et installer Python : Python\nTélécharger et installer Visual Studio Code : Visual Studio Code - Mac, Linux, Windows\nLes extensions et bibliothèques à installer dans VS Code: Python, Run, Pandas, Numpy, Matplotlib, SciPy Tutoriel pour installer des extensions sur VS Code\nInstaller Jupyter Notebook sur Visual Studio Code (en anglais) : How to Install Jupyter Notebook in VSCode | Jupyter Notebook in Visual Studio Code (Easy)\nTutoriel pour VS Code et Jupyter Notebook Voici un fichier qui vous expliquera comment utiliser jupyter notebook dans VS Code : Tutoriel pour utiliser Jupyter avec VS Code\n",
    "description": "",
    "tags": null,
    "title": "VS Code \u0026 Jupyter",
    "uri": "/outils/vs-code--jupyter/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Cours",
    "uri": "/cours/index.html"
  },
  {
    "content": "La programmation lettrée ",
    "description": "",
    "tags": null,
    "title": "Jupyter",
    "uri": "/base-de-connaissances/jupyter/index.html"
  },
  {
    "content": "Cours La répétition en informatique Un des avantages de l’informatique est qu’on est capable de traiter énormément d’information en très peu de temps. Et ce traitement est souvent le même, mais avec des données différentes.\nPar exemple, on a un relevé quotidien de température d’une station météo et on souhaite calculer la température moyenne de chaque semaine de l’année. Dans ce cas, il faut répéter 52 fois une moyenne de 7 températures.\nUn autre exemple, si on a un modèle météorologique et que l’on souhaite tester la relation entre le niveau de CO2 dans l’atmosphère et l’augmentation de la température terrestre. Dans ce cas, il faudra exécuter un grand nombre de simulations en faisant varier le niveau CO2 dans l’atmosphère pour obtenir la température correspondante. On répètera la simulation le nombre fois nécessaire pour couvrir l’amplitude choisie.\nImaginez qu’on souhaite demander à l’utilisateur de saisir le prix unitaire d’un produit, mais que ce prix ne doit pas être négatif. Donc tant que le prix unitaire fourni est négatif, il faut redemander une nouvelle valeur à l’utilisateur.\nprix_unitaire = int(input(\"Entrez le prix unitaire: \")) if prix_unitaire \u003c 0: print(\"Un prix ne peut être négatif\") prix_unitaire = int(input(\"Entrez le prix unitaire: \")) if prix_unitaire \u003c 0: print(\"Un prix ne peut être négatif\") prix_unitaire = int(input(\"Entrez le prix unitaire: \")) if prix_unitaire \u003c 0: print(\"Un prix ne peut être négatif\") #... On voit que sans structure de répétition, on peut continuer cette imbrication de if à l’infini.\nBoucle while Tip\rLa boucle while est pratique pour faire des boucles où on ne sait pas combien de fois on va devoir répéter des instructions. Typiquement avec des saisies utilisateurs. Il faut une condition de sortie.\nprix_unitaire = int(input(\"Entrez le prix unitaire: \")) while prix_unitaire \u003c 0: print(\"Un prix ne peut être négatif\") prix_unitaire = int(input(\"Entrez le prix unitaire: \")) TODO: ajouter ordinogramme\nLa boucle while répète les instructions tant que une certaine condition est remplie. La condition de bouclage prend exactement la même forme que les conditions avec l’instruction if. Vous pouvez donc créer des conditions complexes pour sortir de la boucle.\nPar exemple, on peut modifier la condition pour autoriser seulement les prix unitaires entre 0 et 1000.\nprix_unitaire = int(input(\"Entrez le prix unitaire: \")) while prix_unitaire \u003c 0 or prix_unitaire \u003e 1000: print(\"Un prix ne peut être négatif, ou supéieur a 1000\") prix_unitaire = int(input(\"Entrez le prix unitaire: \")) La forme générique de l’instruction while est :\nwhile \u003ccondition\u003e: instruction1 instruction2 instruction3 ... Boucle infinie while true: instruction1 instruction2 instruction3 ... Pour sortir d’une boucle infinie, il faut utiliser le clavier et taper les touches ctrl+c\nBoucle for Tip\rLa boucle for est pratique pour faire des boucles où on sait à l’avance combien de fois on va devoir répéter des instructions. Typiquement pour le traitement de données, on connait à l’avance le nombre de données que l’on va analyser. Il faut une liste d’éléments.\nLa forme générale de la boucle for est :\nfor variable in range(n): instruction1 instruction2 instruction3 ... La boucle for est basée sur une variable d’itération. Cette variable peut être utilisée dans les instructions de la boucle. Et cette variable prend les valeurs générées par l’instruction range()\nL’instruction range Que fait le code suivant ?\nfor i in range(10): if i % 2 == 0: print(i) range est une instruction qui permet de générer une suite de nombre avec lesquels nous allons faire nos répétitions.\nLa forme générale de la fonction est : range(début, fin, pas)\nSi 1 seul paramètre est spécifié, il s’agit du paramètre fin. Dans ce cas début = 0 et pas = 1.\nrange(10)\r=\u003e [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Si 2 paramètres sont spécifiés, il s’agit des paramètres début et fin. Dans ce cas pas = 1.\nrange(4, 10)\r=\u003e [4, 5, 6, 7, 8, 9] Avec les 3 paramètres spécifiés, on peut obtenir ce genre de résultat :\nrange(2, 100, 10)\r=\u003e [2, 12, 22, 32, 42, 52, 62, 72, 82, 92] Que fait le code suivant ?\nfor i in range(0, 10, 2): print(i) L’instruction break Lorsque l’on parcourt un grand ensemble de données avec une boucle for, on peut vouloir arrêter les calculs si jamais une valeur ne fait pas de sens.\nPar exemple, une donnée négative dans un relevé démographique. Dans ce cas, l’instruction break va interrompre la boucle.\nfor i in range(taille_des_donnees): if data[i] \u003c 0: print(\"Erreur: population négative\") break instruction1 instruction2 instruction3 ... Dans cet exemple, si la population est négative, on alerte l’usagé et on sort de la boucle pour ne par exécuter les instructions suivantes.\nImbrication de boucles Une instruction de bouclage reste une instruction comme les autres, on peut les enchainer les unes dans les autres.\nQue fait le code suivant ?\ncote = 3 for i in range(cote): for j in range(cote): print(\"#\", end=\"\") print(\"\") Warning\rEn règle générale, il est rare d’avoir plus de 3 boucles les unes dans les autres. Si vous devez en imbriquer plus que 3 pour résoudre un algorithme, il y a probablement un problème de logique dans la conception de votre solution.\nRemarque du jour Tip\r90% de temps d’exécution d’un programme se passe dans 10% du code\nIl y a seulement quelques boucles responsables de la majeure partie du temps de calcul d’un programme. C’est en optimisant ces boucles que vous gagnerez en performance.\nLab Atelier sur les boucles\n",
    "description": "",
    "tags": null,
    "title": "La répétition - Les boucles",
    "uri": "/cours/la-r%C3%A9p%C3%A9tition---les-boucles/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Outils",
    "uri": "/outils/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
